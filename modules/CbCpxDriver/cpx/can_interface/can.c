/**
 * @file can.c
 *
 * @brief This source file was generated by cantools version 40.2.2 Wed Jun 18 15:48:26 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <string.h>

#include "can.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u64(
    uint64_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u64(
    uint64_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint64_t unpack_left_shift_u64(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint64_t unpack_right_shift_u64(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) >> shift);
}

int can_inquiry_packet_pack(
    uint8_t *dst_p,
    const struct can_inquiry_packet_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->packet_id, 0u, 0xffu);

    return (8);
}

int can_inquiry_packet_unpack(
    struct can_inquiry_packet_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->packet_id = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

int can_inquiry_packet_init(struct can_inquiry_packet_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_inquiry_packet_t));

    return 0;
}

uint8_t can_inquiry_packet_packet_id_encode(double value)
{
    return (uint8_t)(value);
}

double can_inquiry_packet_packet_id_decode(uint8_t value)
{
    return ((double)value);
}

bool can_inquiry_packet_packet_id_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_digital_output_pack(
    uint8_t *dst_p,
    const struct can_digital_output_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->do_safety_motor_out1, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->do_safety_motor_out2, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->do_cp_invert, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->do_pp_sae_iec, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->do_safety_hvsw1_hs, 6u, 0x40u);
    dst_p[1] |= pack_left_shift_u8(src_p->do_safety_hvsw2_hs, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->do_safety_gpio_exp, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->do_safety_imd_od_en, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->do_pt1000_ctrlen4, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->do_safety_hvsw3_precharge, 1u, 0x02u);
    dst_p[2] |= pack_left_shift_u8(src_p->do_pt1000_ctrlen1, 5u, 0x20u);
    dst_p[2] |= pack_left_shift_u8(src_p->do_pt1000_ctrlen2, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->do_pt1000_ctrlen3, 3u, 0x08u);
    dst_p[2] |= pack_left_shift_u8(src_p->do_safety_cp_state_c, 2u, 0x04u);
    dst_p[3] |= pack_left_shift_u8(src_p->do_cp_dutycycle, 0u, 0xffu);

    return (8);
}

int can_digital_output_unpack(
    struct can_digital_output_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->do_safety_motor_out1 = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->do_safety_motor_out2 = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->do_cp_invert = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->do_pp_sae_iec = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    dst_p->do_safety_hvsw1_hs = unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->do_safety_hvsw2_hs = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->do_safety_gpio_exp = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->do_safety_imd_od_en = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->do_pt1000_ctrlen4 = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->do_safety_hvsw3_precharge = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->do_pt1000_ctrlen1 = unpack_right_shift_u8(src_p[2], 5u, 0x20u);
    dst_p->do_pt1000_ctrlen2 = unpack_right_shift_u8(src_p[2], 4u, 0x10u);
    dst_p->do_pt1000_ctrlen3 = unpack_right_shift_u8(src_p[2], 3u, 0x08u);
    dst_p->do_safety_cp_state_c = unpack_right_shift_u8(src_p[2], 2u, 0x04u);
    dst_p->do_cp_dutycycle = unpack_right_shift_u8(src_p[3], 0u, 0xffu);

    return (0);
}

int can_digital_output_init(struct can_digital_output_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_digital_output_t));

    return 0;
}

uint8_t can_digital_output_do_safety_motor_out1_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_safety_motor_out1_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_safety_motor_out1_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_safety_motor_out2_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_safety_motor_out2_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_safety_motor_out2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_cp_invert_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_cp_invert_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_cp_invert_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_pp_sae_iec_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_pp_sae_iec_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_pp_sae_iec_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_safety_hvsw1_hs_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_safety_hvsw1_hs_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_safety_hvsw1_hs_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_safety_hvsw2_hs_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_safety_hvsw2_hs_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_safety_hvsw2_hs_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_safety_gpio_exp_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_safety_gpio_exp_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_safety_gpio_exp_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_safety_imd_od_en_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_safety_imd_od_en_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_safety_imd_od_en_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_pt1000_ctrlen4_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_pt1000_ctrlen4_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_pt1000_ctrlen4_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_safety_hvsw3_precharge_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_safety_hvsw3_precharge_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_safety_hvsw3_precharge_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_pt1000_ctrlen1_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_pt1000_ctrlen1_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_pt1000_ctrlen1_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_pt1000_ctrlen2_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_pt1000_ctrlen2_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_pt1000_ctrlen2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_pt1000_ctrlen3_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_pt1000_ctrlen3_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_pt1000_ctrlen3_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_safety_cp_state_c_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_safety_cp_state_c_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_safety_cp_state_c_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_output_do_cp_dutycycle_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_output_do_cp_dutycycle_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_output_do_cp_dutycycle_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_diagnostic_measurements2_pack(
    uint8_t *dst_p,
    const struct can_diagnostic_measurements2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->dm_ce_adc_val, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->dm_ce_adc_val, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->dm_id_adc_val, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->dm_id_adc_val, 0u, 0xffu);

    return (8);
}

int can_diagnostic_measurements2_unpack(
    struct can_diagnostic_measurements2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->dm_ce_adc_val = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->dm_ce_adc_val |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->dm_id_adc_val = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->dm_id_adc_val |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);

    return (0);
}

int can_diagnostic_measurements2_init(struct can_diagnostic_measurements2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_diagnostic_measurements2_t));

    return 0;
}

uint16_t can_diagnostic_measurements2_dm_ce_adc_val_encode(double value)
{
    return (uint16_t)(value);
}

double can_diagnostic_measurements2_dm_ce_adc_val_decode(uint16_t value)
{
    return ((double)value);
}

bool can_diagnostic_measurements2_dm_ce_adc_val_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_diagnostic_measurements2_dm_id_adc_val_encode(double value)
{
    return (uint16_t)(value);
}

double can_diagnostic_measurements2_dm_id_adc_val_decode(uint16_t value)
{
    return ((double)value);
}

bool can_diagnostic_measurements2_dm_id_adc_val_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_analog_input04_pack(
    uint8_t *dst_p,
    const struct can_analog_input04_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->ai_pt1000_cfb3_4, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->ai_pt1000_cfb3_4, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->ai_int_temp, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->ai_int_temp, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->ai_int_refvolt, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->ai_int_refvolt, 0u, 0xffu);

    return (8);
}

int can_analog_input04_unpack(
    struct can_analog_input04_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ai_pt1000_cfb3_4 = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->ai_pt1000_cfb3_4 |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->ai_int_temp = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->ai_int_temp |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->ai_int_refvolt = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->ai_int_refvolt |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);

    return (0);
}

int can_analog_input04_init(struct can_analog_input04_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_analog_input04_t));

    return 0;
}

uint16_t can_analog_input04_ai_pt1000_cfb3_4_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input04_ai_pt1000_cfb3_4_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input04_ai_pt1000_cfb3_4_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input04_ai_int_temp_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input04_ai_int_temp_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input04_ai_int_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input04_ai_int_refvolt_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input04_ai_int_refvolt_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input04_ai_int_refvolt_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_analog_input03_pack(
    uint8_t *dst_p,
    const struct can_analog_input03_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->ai_safety_precharge_cfb, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->ai_safety_precharge_cfb, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->ai_safety_hs1_cfb, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->ai_safety_hs1_cfb, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->ai_safety_hs2_cfb, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->ai_safety_hs2_cfb, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->ai_pt1000_cfb1_2, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->ai_pt1000_cfb1_2, 0u, 0xffu);

    return (8);
}

int can_analog_input03_unpack(
    struct can_analog_input03_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ai_safety_precharge_cfb = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->ai_safety_precharge_cfb |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->ai_safety_hs1_cfb = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->ai_safety_hs1_cfb |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->ai_safety_hs2_cfb = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->ai_safety_hs2_cfb |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->ai_pt1000_cfb1_2 = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->ai_pt1000_cfb1_2 |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int can_analog_input03_init(struct can_analog_input03_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_analog_input03_t));

    return 0;
}

uint16_t can_analog_input03_ai_safety_precharge_cfb_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input03_ai_safety_precharge_cfb_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input03_ai_safety_precharge_cfb_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input03_ai_safety_hs1_cfb_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input03_ai_safety_hs1_cfb_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input03_ai_safety_hs1_cfb_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input03_ai_safety_hs2_cfb_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input03_ai_safety_hs2_cfb_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input03_ai_safety_hs2_cfb_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input03_ai_pt1000_cfb1_2_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input03_ai_pt1000_cfb1_2_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input03_ai_pt1000_cfb1_2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_analog_input02_pack(
    uint8_t *dst_p,
    const struct can_analog_input02_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->ai_cp_buffered_neg_adc, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->ai_cp_buffered_neg_adc, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->ai_cp_buffered_pos_adc, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->ai_cp_buffered_pos_adc, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->ai_pp_value_adc, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->ai_pp_value_adc, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->ai_safety_u_in_adc, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->ai_safety_u_in_adc, 0u, 0xffu);

    return (8);
}

int can_analog_input02_unpack(
    struct can_analog_input02_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ai_cp_buffered_neg_adc = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->ai_cp_buffered_neg_adc |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->ai_cp_buffered_pos_adc = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->ai_cp_buffered_pos_adc |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->ai_pp_value_adc = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->ai_pp_value_adc |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->ai_safety_u_in_adc = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->ai_safety_u_in_adc |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int can_analog_input02_init(struct can_analog_input02_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_analog_input02_t));

    return 0;
}

uint16_t can_analog_input02_ai_cp_buffered_neg_adc_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input02_ai_cp_buffered_neg_adc_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input02_ai_cp_buffered_neg_adc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input02_ai_cp_buffered_pos_adc_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input02_ai_cp_buffered_pos_adc_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input02_ai_cp_buffered_pos_adc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input02_ai_pp_value_adc_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input02_ai_pp_value_adc_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input02_ai_pp_value_adc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input02_ai_safety_u_in_adc_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input02_ai_safety_u_in_adc_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input02_ai_safety_u_in_adc_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_analog_input01_pack(
    uint8_t *dst_p,
    const struct can_analog_input01_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u16(src_p->ai_pt1000_lead1_1, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->ai_pt1000_lead1_1, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->ai_pt1000_lead1_2, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->ai_pt1000_lead1_2, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->ai_pt1000_lead1_3, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->ai_pt1000_lead1_3, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->ai_pt1000_lead1_4, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->ai_pt1000_lead1_4, 0u, 0xffu);

    return (8);
}

int can_analog_input01_unpack(
    struct can_analog_input01_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->ai_pt1000_lead1_1 = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dst_p->ai_pt1000_lead1_1 |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->ai_pt1000_lead1_2 = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->ai_pt1000_lead1_2 |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->ai_pt1000_lead1_3 = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->ai_pt1000_lead1_3 |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->ai_pt1000_lead1_4 = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->ai_pt1000_lead1_4 |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int can_analog_input01_init(struct can_analog_input01_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_analog_input01_t));

    return 0;
}

uint16_t can_analog_input01_ai_pt1000_lead1_1_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input01_ai_pt1000_lead1_1_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input01_ai_pt1000_lead1_1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input01_ai_pt1000_lead1_2_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input01_ai_pt1000_lead1_2_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input01_ai_pt1000_lead1_2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input01_ai_pt1000_lead1_3_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input01_ai_pt1000_lead1_3_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input01_ai_pt1000_lead1_3_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_analog_input01_ai_pt1000_lead1_4_encode(double value)
{
    return (uint16_t)(value);
}

double can_analog_input01_ai_pt1000_lead1_4_decode(uint16_t value)
{
    return ((double)value);
}

bool can_analog_input01_ai_pt1000_lead1_4_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_charge_control2_pack(
    uint8_t *dst_p,
    const struct can_charge_control2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->cc_ccs_ready, 4u, 0xf0u);
    dst_p[0] |= pack_left_shift_u8(src_p->cc_controller_reset, 2u, 0x0cu);

    return (8);
}

int can_charge_control2_unpack(
    struct can_charge_control2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->cc_ccs_ready = unpack_right_shift_u8(src_p[0], 4u, 0xf0u);
    dst_p->cc_controller_reset = unpack_right_shift_u8(src_p[0], 2u, 0x0cu);

    return (0);
}

int can_charge_control2_init(struct can_charge_control2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_charge_control2_t));

    return 0;
}

uint8_t can_charge_control2_cc_ccs_ready_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_control2_cc_ccs_ready_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_control2_cc_ccs_ready_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_charge_control2_cc_controller_reset_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_control2_cc_controller_reset_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_control2_cc_controller_reset_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int can_charge_state2_pack(
    uint8_t *dst_p,
    const struct can_charge_state2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->cs_ce_state, 4u, 0xf0u);
    dst_p[0] |= pack_left_shift_u8(src_p->cs_id_state, 0u, 0x0fu);
    dst_p[1] |= pack_left_shift_u8(src_p->cs_e_stop_reason, 0u, 0xffu);

    return (8);
}

int can_charge_state2_unpack(
    struct can_charge_state2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->cs_ce_state = unpack_right_shift_u8(src_p[0], 4u, 0xf0u);
    dst_p->cs_id_state = unpack_right_shift_u8(src_p[0], 0u, 0x0fu);
    dst_p->cs_e_stop_reason = unpack_right_shift_u8(src_p[1], 0u, 0xffu);

    return (0);
}

int can_charge_state2_init(struct can_charge_state2_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_charge_state2_t));

    return 0;
}

uint8_t can_charge_state2_cs_ce_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state2_cs_ce_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state2_cs_ce_state_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_charge_state2_cs_id_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state2_cs_id_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state2_cs_id_state_is_in_range(uint8_t value)
{
    return (value <= 15u);
}

uint8_t can_charge_state2_cs_e_stop_reason_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state2_cs_e_stop_reason_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state2_cs_e_stop_reason_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_charge_state1_pack(
    uint8_t *dst_p,
    const struct can_charge_state1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->cs_pwm_active, 7u, 0x80u);
    dst_p[0] |= pack_right_shift_u16(src_p->cs_current_duty_cycle, 8u, 0x03u);
    dst_p[1] |= pack_left_shift_u16(src_p->cs_current_duty_cycle, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->cs_diode_fault, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->cs_cp_short_circuit, 3u, 0x08u);
    dst_p[2] |= pack_left_shift_u8(src_p->cs_current_cp_state, 0u, 0x07u);
    dst_p[3] |= pack_left_shift_u8(src_p->cs_current_pp_state, 0u, 0x07u);
    dst_p[4] |= pack_left_shift_u8(src_p->cs_hv_ready, 6u, 0x40u);
    dst_p[4] |= pack_left_shift_u8(src_p->cs_contactor2_error, 5u, 0x20u);
    dst_p[4] |= pack_left_shift_u8(src_p->cs_contactor2_state, 3u, 0x18u);
    dst_p[4] |= pack_left_shift_u8(src_p->cs_contactor1_error, 2u, 0x04u);
    dst_p[4] |= pack_left_shift_u8(src_p->cs_contactor1_state, 0u, 0x03u);
    dst_p[5] |= pack_left_shift_u8(src_p->cs_estop3_charging_abort, 4u, 0x30u);
    dst_p[5] |= pack_left_shift_u8(src_p->cs_estop2_charging_abort, 2u, 0x0cu);
    dst_p[5] |= pack_left_shift_u8(src_p->cs_estop1_charging_abort, 0u, 0x03u);

    return (8);
}

int can_charge_state1_unpack(
    struct can_charge_state1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->cs_pwm_active = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->cs_current_duty_cycle = unpack_left_shift_u16(src_p[0], 8u, 0x03u);
    dst_p->cs_current_duty_cycle |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->cs_diode_fault = unpack_right_shift_u8(src_p[2], 4u, 0x10u);
    dst_p->cs_cp_short_circuit = unpack_right_shift_u8(src_p[2], 3u, 0x08u);
    dst_p->cs_current_cp_state = unpack_right_shift_u8(src_p[2], 0u, 0x07u);
    dst_p->cs_current_pp_state = unpack_right_shift_u8(src_p[3], 0u, 0x07u);
    dst_p->cs_hv_ready = unpack_right_shift_u8(src_p[4], 6u, 0x40u);
    dst_p->cs_contactor2_error = unpack_right_shift_u8(src_p[4], 5u, 0x20u);
    dst_p->cs_contactor2_state = unpack_right_shift_u8(src_p[4], 3u, 0x18u);
    dst_p->cs_contactor1_error = unpack_right_shift_u8(src_p[4], 2u, 0x04u);
    dst_p->cs_contactor1_state = unpack_right_shift_u8(src_p[4], 0u, 0x03u);
    dst_p->cs_estop3_charging_abort = unpack_right_shift_u8(src_p[5], 4u, 0x30u);
    dst_p->cs_estop2_charging_abort = unpack_right_shift_u8(src_p[5], 2u, 0x0cu);
    dst_p->cs_estop1_charging_abort = unpack_right_shift_u8(src_p[5], 0u, 0x03u);

    return (0);
}

int can_charge_state1_init(struct can_charge_state1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_charge_state1_t));

    return 0;
}

uint8_t can_charge_state1_cs_pwm_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_pwm_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_pwm_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t can_charge_state1_cs_current_duty_cycle_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can_charge_state1_cs_current_duty_cycle_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can_charge_state1_cs_current_duty_cycle_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint8_t can_charge_state1_cs_diode_fault_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_diode_fault_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_diode_fault_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_charge_state1_cs_cp_short_circuit_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_cp_short_circuit_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_cp_short_circuit_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_charge_state1_cs_current_cp_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_current_cp_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_current_cp_state_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t can_charge_state1_cs_current_pp_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_current_pp_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_current_pp_state_is_in_range(uint8_t value)
{
    return (value <= 7u);
}

uint8_t can_charge_state1_cs_hv_ready_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_hv_ready_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_hv_ready_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_charge_state1_cs_contactor2_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_contactor2_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_contactor2_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_charge_state1_cs_contactor2_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_contactor2_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_contactor2_state_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_charge_state1_cs_contactor1_error_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_contactor1_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_contactor1_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_charge_state1_cs_contactor1_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_contactor1_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_contactor1_state_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_charge_state1_cs_estop3_charging_abort_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_estop3_charging_abort_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_estop3_charging_abort_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_charge_state1_cs_estop2_charging_abort_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_estop2_charging_abort_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_estop2_charging_abort_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

uint8_t can_charge_state1_cs_estop1_charging_abort_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_state1_cs_estop1_charging_abort_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_state1_cs_estop1_charging_abort_is_in_range(uint8_t value)
{
    return (value <= 3u);
}

int can_charge_control1_pack(
    uint8_t *dst_p,
    const struct can_charge_control1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->cc_pwm_active, 7u, 0x80u);
    dst_p[0] |= pack_right_shift_u16(src_p->cc_target_duty_cycle, 8u, 0x03u);
    dst_p[1] |= pack_left_shift_u16(src_p->cc_target_duty_cycle, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->cc_contactor2_state, 1u, 0x02u);
    dst_p[2] |= pack_left_shift_u8(src_p->cc_contactor1_state, 0u, 0x01u);

    return (8);
}

int can_charge_control1_unpack(
    struct can_charge_control1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->cc_pwm_active = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->cc_target_duty_cycle = unpack_left_shift_u16(src_p[0], 8u, 0x03u);
    dst_p->cc_target_duty_cycle |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->cc_contactor2_state = unpack_right_shift_u8(src_p[2], 1u, 0x02u);
    dst_p->cc_contactor1_state = unpack_right_shift_u8(src_p[2], 0u, 0x01u);

    return (0);
}

int can_charge_control1_init(struct can_charge_control1_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_charge_control1_t));

    return 0;
}

uint8_t can_charge_control1_cc_pwm_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_control1_cc_pwm_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_control1_cc_pwm_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t can_charge_control1_cc_target_duty_cycle_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can_charge_control1_cc_target_duty_cycle_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can_charge_control1_cc_target_duty_cycle_is_in_range(uint16_t value)
{
    return (value <= 1023u);
}

uint8_t can_charge_control1_cc_contactor2_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_control1_cc_contactor2_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_control1_cc_contactor2_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_charge_control1_cc_contactor1_state_encode(double value)
{
    return (uint8_t)(value);
}

double can_charge_control1_cc_contactor1_state_decode(uint8_t value)
{
    return ((double)value);
}

bool can_charge_control1_cc_contactor1_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_firmware_version_pack(
    uint8_t *dst_p,
    const struct can_firmware_version_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->major_version, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->minor_version, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->build_version, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->platform_type, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->application_type, 0u, 0xffu);

    return (8);
}

int can_firmware_version_unpack(
    struct can_firmware_version_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->major_version = unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->minor_version = unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->build_version = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->platform_type = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->application_type = unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

int can_firmware_version_init(struct can_firmware_version_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_firmware_version_t));

    return 0;
}

uint8_t can_firmware_version_major_version_encode(double value)
{
    return (uint8_t)(value);
}

double can_firmware_version_major_version_decode(uint8_t value)
{
    return ((double)value);
}

bool can_firmware_version_major_version_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_firmware_version_minor_version_encode(double value)
{
    return (uint8_t)(value);
}

double can_firmware_version_minor_version_decode(uint8_t value)
{
    return ((double)value);
}

bool can_firmware_version_minor_version_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_firmware_version_build_version_encode(double value)
{
    return (uint8_t)(value);
}

double can_firmware_version_build_version_decode(uint8_t value)
{
    return ((double)value);
}

bool can_firmware_version_build_version_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_firmware_version_platform_type_encode(double value)
{
    return (uint8_t)(value);
}

double can_firmware_version_platform_type_decode(uint8_t value)
{
    return ((double)value);
}

bool can_firmware_version_platform_type_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t can_firmware_version_application_type_encode(double value)
{
    return (uint8_t)(value);
}

double can_firmware_version_application_type_decode(uint8_t value)
{
    return ((double)value);
}

bool can_firmware_version_application_type_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can_git_hash_pack(
    uint8_t *dst_p,
    const struct can_git_hash_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_right_shift_u64(src_p->hash_signal, 56u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(src_p->hash_signal, 48u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(src_p->hash_signal, 40u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(src_p->hash_signal, 32u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(src_p->hash_signal, 24u, 0xffu);
    dst_p[5] |= pack_right_shift_u64(src_p->hash_signal, 16u, 0xffu);
    dst_p[6] |= pack_right_shift_u64(src_p->hash_signal, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u64(src_p->hash_signal, 0u, 0xffu);

    return (8);
}

int can_git_hash_unpack(
    struct can_git_hash_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->hash_signal = unpack_left_shift_u64(src_p[0], 56u, 0xffu);
    dst_p->hash_signal |= unpack_left_shift_u64(src_p[1], 48u, 0xffu);
    dst_p->hash_signal |= unpack_left_shift_u64(src_p[2], 40u, 0xffu);
    dst_p->hash_signal |= unpack_left_shift_u64(src_p[3], 32u, 0xffu);
    dst_p->hash_signal |= unpack_left_shift_u64(src_p[4], 24u, 0xffu);
    dst_p->hash_signal |= unpack_left_shift_u64(src_p[5], 16u, 0xffu);
    dst_p->hash_signal |= unpack_left_shift_u64(src_p[6], 8u, 0xffu);
    dst_p->hash_signal |= unpack_right_shift_u64(src_p[7], 0u, 0xffu);

    return (0);
}

int can_git_hash_init(struct can_git_hash_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_git_hash_t));

    return 0;
}

uint64_t can_git_hash_hash_signal_encode(double value)
{
    return (uint64_t)(value);
}

double can_git_hash_hash_signal_decode(uint64_t value)
{
    return ((double)value);
}

bool can_git_hash_hash_signal_is_in_range(uint64_t value)
{
    (void)value;

    return (true);
}

int can_error_message_pack(
    uint8_t *dst_p,
    const struct can_error_message_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->error_active, 7u, 0x80u);
    dst_p[0] |= pack_right_shift_u16(src_p->error_module, 8u, 0x7fu);
    dst_p[1] |= pack_left_shift_u16(src_p->error_module, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->error_reason, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->error_reason, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->error_add_data1, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->error_add_data1, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->error_add_data2, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(src_p->error_add_data2, 0u, 0xffu);

    return (8);
}

int can_error_message_unpack(
    struct can_error_message_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->error_active = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->error_module = unpack_left_shift_u16(src_p[0], 8u, 0x7fu);
    dst_p->error_module |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->error_reason = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->error_reason |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->error_add_data1 = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->error_add_data1 |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->error_add_data2 = unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->error_add_data2 |= unpack_right_shift_u16(src_p[7], 0u, 0xffu);

    return (0);
}

int can_error_message_init(struct can_error_message_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_error_message_t));

    return 0;
}

uint8_t can_error_message_error_active_encode(double value)
{
    return (uint8_t)(value);
}

double can_error_message_error_active_decode(uint8_t value)
{
    return ((double)value);
}

bool can_error_message_error_active_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t can_error_message_error_module_encode(double value)
{
    return (uint16_t)(value);
}

double can_error_message_error_module_decode(uint16_t value)
{
    return ((double)value);
}

bool can_error_message_error_module_is_in_range(uint16_t value)
{
    return (value <= 32767u);
}

uint16_t can_error_message_error_reason_encode(double value)
{
    return (uint16_t)(value);
}

double can_error_message_error_reason_decode(uint16_t value)
{
    return ((double)value);
}

bool can_error_message_error_reason_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_error_message_error_add_data1_encode(double value)
{
    return (uint16_t)(value);
}

double can_error_message_error_add_data1_decode(uint16_t value)
{
    return ((double)value);
}

bool can_error_message_error_add_data1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can_error_message_error_add_data2_encode(double value)
{
    return (uint16_t)(value);
}

double can_error_message_error_add_data2_decode(uint16_t value)
{
    return ((double)value);
}

bool can_error_message_error_add_data2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can_diagnostic_measurements_pack(
    uint8_t *dst_p,
    const struct can_diagnostic_measurements_t *src_p,
    size_t size)
{
    uint16_t dm_cp_voltage_negative_side;
    uint16_t dm_cp_voltage_positive_side;
    uint16_t dm_pp_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dm_cp_voltage_negative_side = (uint16_t)src_p->dm_cp_voltage_negative_side;
    dst_p[0] |= pack_right_shift_u16(dm_cp_voltage_negative_side, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(dm_cp_voltage_negative_side, 0u, 0xffu);
    dm_cp_voltage_positive_side = (uint16_t)src_p->dm_cp_voltage_positive_side;
    dst_p[2] |= pack_right_shift_u16(dm_cp_voltage_positive_side, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(dm_cp_voltage_positive_side, 0u, 0xffu);
    dm_pp_voltage = (uint16_t)src_p->dm_pp_voltage;
    dst_p[4] |= pack_right_shift_u16(dm_pp_voltage, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(dm_pp_voltage, 0u, 0xffu);

    return (8);
}

int can_diagnostic_measurements_unpack(
    struct can_diagnostic_measurements_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t dm_cp_voltage_negative_side;
    uint16_t dm_cp_voltage_positive_side;
    uint16_t dm_pp_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    dm_cp_voltage_negative_side = unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    dm_cp_voltage_negative_side |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->dm_cp_voltage_negative_side = (int16_t)dm_cp_voltage_negative_side;
    dm_cp_voltage_positive_side = unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dm_cp_voltage_positive_side |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->dm_cp_voltage_positive_side = (int16_t)dm_cp_voltage_positive_side;
    dm_pp_voltage = unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dm_pp_voltage |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->dm_pp_voltage = (int16_t)dm_pp_voltage;

    return (0);
}

int can_diagnostic_measurements_init(struct can_diagnostic_measurements_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_diagnostic_measurements_t));

    return 0;
}

int16_t can_diagnostic_measurements_dm_cp_voltage_negative_side_encode(double value)
{
    return (int16_t)(value);
}

double can_diagnostic_measurements_dm_cp_voltage_negative_side_decode(int16_t value)
{
    return ((double)value);
}

bool can_diagnostic_measurements_dm_cp_voltage_negative_side_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_diagnostic_measurements_dm_cp_voltage_positive_side_encode(double value)
{
    return (int16_t)(value);
}

double can_diagnostic_measurements_dm_cp_voltage_positive_side_decode(int16_t value)
{
    return ((double)value);
}

bool can_diagnostic_measurements_dm_cp_voltage_positive_side_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can_diagnostic_measurements_dm_pp_voltage_encode(double value)
{
    return (int16_t)(value);
}

double can_diagnostic_measurements_dm_pp_voltage_decode(int16_t value)
{
    return ((double)value);
}

bool can_diagnostic_measurements_dm_pp_voltage_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can_pt1000_state_pack(
    uint8_t *dst_p,
    const struct can_pt1000_state_t *src_p,
    size_t size)
{
    uint16_t pt1_temperature;
    uint16_t pt2_temperature;
    uint16_t pt3_temperature;
    uint16_t pt4_temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    pt1_temperature = (uint16_t)src_p->pt1_temperature;
    dst_p[0] |= pack_right_shift_u16(pt1_temperature, 6u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(pt1_temperature, 2u, 0xfcu);
    dst_p[1] |= pack_left_shift_u8(src_p->pt1_selftest_failed, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->pt1_charging_stopped, 0u, 0x01u);
    pt2_temperature = (uint16_t)src_p->pt2_temperature;
    dst_p[2] |= pack_right_shift_u16(pt2_temperature, 6u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(pt2_temperature, 2u, 0xfcu);
    dst_p[3] |= pack_left_shift_u8(src_p->pt2_selftest_failed, 1u, 0x02u);
    dst_p[3] |= pack_left_shift_u8(src_p->pt2_charging_stopped, 0u, 0x01u);
    pt3_temperature = (uint16_t)src_p->pt3_temperature;
    dst_p[4] |= pack_right_shift_u16(pt3_temperature, 6u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(pt3_temperature, 2u, 0xfcu);
    dst_p[5] |= pack_left_shift_u8(src_p->pt3_selftest_failed, 1u, 0x02u);
    dst_p[5] |= pack_left_shift_u8(src_p->pt3_charging_stopped, 0u, 0x01u);
    pt4_temperature = (uint16_t)src_p->pt4_temperature;
    dst_p[6] |= pack_right_shift_u16(pt4_temperature, 6u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(pt4_temperature, 2u, 0xfcu);
    dst_p[7] |= pack_left_shift_u8(src_p->pt4_selftest_failed, 1u, 0x02u);
    dst_p[7] |= pack_left_shift_u8(src_p->pt4_charging_stopped, 0u, 0x01u);

    return (8);
}

int can_pt1000_state_unpack(
    struct can_pt1000_state_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t pt1_temperature;
    uint16_t pt2_temperature;
    uint16_t pt3_temperature;
    uint16_t pt4_temperature;

    if (size < 8u) {
        return (-EINVAL);
    }

    pt1_temperature = unpack_left_shift_u16(src_p[0], 6u, 0xffu);
    pt1_temperature |= unpack_right_shift_u16(src_p[1], 2u, 0xfcu);

    if ((pt1_temperature & (1u << 13)) != 0u) {
        pt1_temperature |= 0xc000u;
    }

    dst_p->pt1_temperature = (int16_t)pt1_temperature;
    dst_p->pt1_selftest_failed = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->pt1_charging_stopped = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    pt2_temperature = unpack_left_shift_u16(src_p[2], 6u, 0xffu);
    pt2_temperature |= unpack_right_shift_u16(src_p[3], 2u, 0xfcu);

    if ((pt2_temperature & (1u << 13)) != 0u) {
        pt2_temperature |= 0xc000u;
    }

    dst_p->pt2_temperature = (int16_t)pt2_temperature;
    dst_p->pt2_selftest_failed = unpack_right_shift_u8(src_p[3], 1u, 0x02u);
    dst_p->pt2_charging_stopped = unpack_right_shift_u8(src_p[3], 0u, 0x01u);
    pt3_temperature = unpack_left_shift_u16(src_p[4], 6u, 0xffu);
    pt3_temperature |= unpack_right_shift_u16(src_p[5], 2u, 0xfcu);

    if ((pt3_temperature & (1u << 13)) != 0u) {
        pt3_temperature |= 0xc000u;
    }

    dst_p->pt3_temperature = (int16_t)pt3_temperature;
    dst_p->pt3_selftest_failed = unpack_right_shift_u8(src_p[5], 1u, 0x02u);
    dst_p->pt3_charging_stopped = unpack_right_shift_u8(src_p[5], 0u, 0x01u);
    pt4_temperature = unpack_left_shift_u16(src_p[6], 6u, 0xffu);
    pt4_temperature |= unpack_right_shift_u16(src_p[7], 2u, 0xfcu);

    if ((pt4_temperature & (1u << 13)) != 0u) {
        pt4_temperature |= 0xc000u;
    }

    dst_p->pt4_temperature = (int16_t)pt4_temperature;
    dst_p->pt4_selftest_failed = unpack_right_shift_u8(src_p[7], 1u, 0x02u);
    dst_p->pt4_charging_stopped = unpack_right_shift_u8(src_p[7], 0u, 0x01u);

    return (0);
}

int can_pt1000_state_init(struct can_pt1000_state_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_pt1000_state_t));

    return 0;
}

int16_t can_pt1000_state_pt1_temperature_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_pt1000_state_pt1_temperature_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_pt1000_state_pt1_temperature_is_in_range(int16_t value)
{
    return ((value >= -8192) && (value <= 8191));
}

uint8_t can_pt1000_state_pt1_selftest_failed_encode(double value)
{
    return (uint8_t)(value);
}

double can_pt1000_state_pt1_selftest_failed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_pt1000_state_pt1_selftest_failed_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_pt1000_state_pt1_charging_stopped_encode(double value)
{
    return (uint8_t)(value);
}

double can_pt1000_state_pt1_charging_stopped_decode(uint8_t value)
{
    return ((double)value);
}

bool can_pt1000_state_pt1_charging_stopped_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int16_t can_pt1000_state_pt2_temperature_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_pt1000_state_pt2_temperature_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_pt1000_state_pt2_temperature_is_in_range(int16_t value)
{
    return ((value >= -8192) && (value <= 8191));
}

uint8_t can_pt1000_state_pt2_selftest_failed_encode(double value)
{
    return (uint8_t)(value);
}

double can_pt1000_state_pt2_selftest_failed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_pt1000_state_pt2_selftest_failed_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_pt1000_state_pt2_charging_stopped_encode(double value)
{
    return (uint8_t)(value);
}

double can_pt1000_state_pt2_charging_stopped_decode(uint8_t value)
{
    return ((double)value);
}

bool can_pt1000_state_pt2_charging_stopped_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int16_t can_pt1000_state_pt3_temperature_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_pt1000_state_pt3_temperature_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_pt1000_state_pt3_temperature_is_in_range(int16_t value)
{
    return ((value >= -8192) && (value <= 8191));
}

uint8_t can_pt1000_state_pt3_selftest_failed_encode(double value)
{
    return (uint8_t)(value);
}

double can_pt1000_state_pt3_selftest_failed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_pt1000_state_pt3_selftest_failed_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_pt1000_state_pt3_charging_stopped_encode(double value)
{
    return (uint8_t)(value);
}

double can_pt1000_state_pt3_charging_stopped_decode(uint8_t value)
{
    return ((double)value);
}

bool can_pt1000_state_pt3_charging_stopped_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int16_t can_pt1000_state_pt4_temperature_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can_pt1000_state_pt4_temperature_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can_pt1000_state_pt4_temperature_is_in_range(int16_t value)
{
    return ((value >= -8192) && (value <= 8191));
}

uint8_t can_pt1000_state_pt4_selftest_failed_encode(double value)
{
    return (uint8_t)(value);
}

double can_pt1000_state_pt4_selftest_failed_decode(uint8_t value)
{
    return ((double)value);
}

bool can_pt1000_state_pt4_selftest_failed_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_pt1000_state_pt4_charging_stopped_encode(double value)
{
    return (uint8_t)(value);
}

double can_pt1000_state_pt4_charging_stopped_decode(uint8_t value)
{
    return ((double)value);
}

bool can_pt1000_state_pt4_charging_stopped_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int can_digital_input_pack(
    uint8_t *dst_p,
    const struct can_digital_input_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->di_safety_k1_in, 7u, 0x80u);
    dst_p[0] |= pack_left_shift_u8(src_p->di_safety_motor_out1, 6u, 0x40u);
    dst_p[0] |= pack_left_shift_u8(src_p->di_safety_motor_out2, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->di_safety_motor_fault, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->di_cp_invert, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->di_ev_cp_edge, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->di_safety_dev_2, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->di_safety_dev_1, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->di_pp_sae_iec, 7u, 0x80u);
    dst_p[1] |= pack_left_shift_u8(src_p->di_safety_hvsw1_hs, 6u, 0x40u);
    dst_p[1] |= pack_left_shift_u8(src_p->di_safety_hvsw2_hs, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->di_safety_gpio_exp, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->di_safety_imd_od_en, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->di_pt4_en, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->di_safety_hvsw3_precharge, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->di_safety_k2_in, 0u, 0x01u);
    dst_p[2] |= pack_left_shift_u8(src_p->di_pt1_en, 6u, 0x40u);
    dst_p[2] |= pack_left_shift_u8(src_p->di_pt2_en, 5u, 0x20u);
    dst_p[2] |= pack_left_shift_u8(src_p->di_pt3_en, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->di_safety_cp_state_c, 3u, 0x08u);
    dst_p[2] |= pack_left_shift_u8(src_p->di_estop1, 2u, 0x04u);
    dst_p[2] |= pack_left_shift_u8(src_p->di_estop2, 1u, 0x02u);
    dst_p[2] |= pack_left_shift_u8(src_p->di_estop3, 0u, 0x01u);

    return (8);
}

int can_digital_input_unpack(
    struct can_digital_input_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->di_safety_k1_in = unpack_right_shift_u8(src_p[0], 7u, 0x80u);
    dst_p->di_safety_motor_out1 = unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->di_safety_motor_out2 = unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->di_safety_motor_fault = unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->di_cp_invert = unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->di_ev_cp_edge = unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->di_safety_dev_2 = unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->di_safety_dev_1 = unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->di_pp_sae_iec = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    dst_p->di_safety_hvsw1_hs = unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->di_safety_hvsw2_hs = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->di_safety_gpio_exp = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->di_safety_imd_od_en = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->di_pt4_en = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->di_safety_hvsw3_precharge = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->di_safety_k2_in = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->di_pt1_en = unpack_right_shift_u8(src_p[2], 6u, 0x40u);
    dst_p->di_pt2_en = unpack_right_shift_u8(src_p[2], 5u, 0x20u);
    dst_p->di_pt3_en = unpack_right_shift_u8(src_p[2], 4u, 0x10u);
    dst_p->di_safety_cp_state_c = unpack_right_shift_u8(src_p[2], 3u, 0x08u);
    dst_p->di_estop1 = unpack_right_shift_u8(src_p[2], 2u, 0x04u);
    dst_p->di_estop2 = unpack_right_shift_u8(src_p[2], 1u, 0x02u);
    dst_p->di_estop3 = unpack_right_shift_u8(src_p[2], 0u, 0x01u);

    return (0);
}

int can_digital_input_init(struct can_digital_input_t *msg_p)
{
    if (msg_p == NULL) return -1;

    memset(msg_p, 0, sizeof(struct can_digital_input_t));

    return 0;
}

uint8_t can_digital_input_di_safety_k1_in_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_k1_in_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_k1_in_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_motor_out1_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_motor_out1_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_motor_out1_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_motor_out2_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_motor_out2_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_motor_out2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_motor_fault_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_motor_fault_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_motor_fault_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_cp_invert_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_cp_invert_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_cp_invert_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_ev_cp_edge_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_ev_cp_edge_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_ev_cp_edge_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_dev_2_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_dev_2_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_dev_2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_dev_1_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_dev_1_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_dev_1_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_pp_sae_iec_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_pp_sae_iec_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_pp_sae_iec_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_hvsw1_hs_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_hvsw1_hs_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_hvsw1_hs_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_hvsw2_hs_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_hvsw2_hs_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_hvsw2_hs_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_gpio_exp_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_gpio_exp_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_gpio_exp_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_imd_od_en_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_imd_od_en_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_imd_od_en_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_pt4_en_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_pt4_en_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_pt4_en_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_hvsw3_precharge_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_hvsw3_precharge_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_hvsw3_precharge_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_k2_in_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_k2_in_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_k2_in_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_pt1_en_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_pt1_en_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_pt1_en_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_pt2_en_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_pt2_en_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_pt2_en_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_pt3_en_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_pt3_en_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_pt3_en_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_safety_cp_state_c_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_safety_cp_state_c_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_safety_cp_state_c_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_estop1_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_estop1_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_estop1_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_estop2_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_estop2_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_estop2_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can_digital_input_di_estop3_encode(double value)
{
    return (uint8_t)(value);
}

double can_digital_input_di_estop3_decode(uint8_t value)
{
    return ((double)value);
}

bool can_digital_input_di_estop3_is_in_range(uint8_t value)
{
    return (value <= 1u);
}
