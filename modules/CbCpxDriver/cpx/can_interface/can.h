/**
 * @file can.h
 *
 * @brief This header file was generated by cantools version 40.2.2 Wed Jun 18 15:48:26 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef CAN_H
#define CAN_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_INQUIRY_PACKET_FRAME_ID (0xffu)
#define CAN_DIGITAL_OUTPUT_FRAME_ID (0x00u)
#define CAN_DIAGNOSTIC_MEASUREMENTS2_FRAME_ID (0x12u)
#define CAN_ANALOG_INPUT04_FRAME_ID (0x05u)
#define CAN_ANALOG_INPUT03_FRAME_ID (0x04u)
#define CAN_ANALOG_INPUT02_FRAME_ID (0x03u)
#define CAN_ANALOG_INPUT01_FRAME_ID (0x02u)
#define CAN_CHARGE_CONTROL2_FRAME_ID (0x11u)
#define CAN_CHARGE_STATE2_FRAME_ID (0x10u)
#define CAN_CHARGE_STATE1_FRAME_ID (0x07u)
#define CAN_CHARGE_CONTROL1_FRAME_ID (0x06u)
#define CAN_FIRMWARE_VERSION_FRAME_ID (0x0au)
#define CAN_GIT_HASH_FRAME_ID (0x0bu)
#define CAN_ERROR_MESSAGE_FRAME_ID (0x0eu)
#define CAN_DIAGNOSTIC_MEASUREMENTS_FRAME_ID (0x09u)
#define CAN_PT1000_STATE_FRAME_ID (0x08u)
#define CAN_DIGITAL_INPUT_FRAME_ID (0x01u)

/* Frame lengths in bytes. */
#define CAN_INQUIRY_PACKET_LENGTH (8u)
#define CAN_DIGITAL_OUTPUT_LENGTH (8u)
#define CAN_DIAGNOSTIC_MEASUREMENTS2_LENGTH (8u)
#define CAN_ANALOG_INPUT04_LENGTH (8u)
#define CAN_ANALOG_INPUT03_LENGTH (8u)
#define CAN_ANALOG_INPUT02_LENGTH (8u)
#define CAN_ANALOG_INPUT01_LENGTH (8u)
#define CAN_CHARGE_CONTROL2_LENGTH (8u)
#define CAN_CHARGE_STATE2_LENGTH (8u)
#define CAN_CHARGE_STATE1_LENGTH (8u)
#define CAN_CHARGE_CONTROL1_LENGTH (8u)
#define CAN_FIRMWARE_VERSION_LENGTH (8u)
#define CAN_GIT_HASH_LENGTH (8u)
#define CAN_ERROR_MESSAGE_LENGTH (8u)
#define CAN_DIAGNOSTIC_MEASUREMENTS_LENGTH (8u)
#define CAN_PT1000_STATE_LENGTH (8u)
#define CAN_DIGITAL_INPUT_LENGTH (8u)

/* Extended or standard frame types. */
#define CAN_INQUIRY_PACKET_IS_EXTENDED (0)
#define CAN_DIGITAL_OUTPUT_IS_EXTENDED (0)
#define CAN_DIAGNOSTIC_MEASUREMENTS2_IS_EXTENDED (0)
#define CAN_ANALOG_INPUT04_IS_EXTENDED (0)
#define CAN_ANALOG_INPUT03_IS_EXTENDED (0)
#define CAN_ANALOG_INPUT02_IS_EXTENDED (0)
#define CAN_ANALOG_INPUT01_IS_EXTENDED (0)
#define CAN_CHARGE_CONTROL2_IS_EXTENDED (0)
#define CAN_CHARGE_STATE2_IS_EXTENDED (0)
#define CAN_CHARGE_STATE1_IS_EXTENDED (0)
#define CAN_CHARGE_CONTROL1_IS_EXTENDED (0)
#define CAN_FIRMWARE_VERSION_IS_EXTENDED (0)
#define CAN_GIT_HASH_IS_EXTENDED (0)
#define CAN_ERROR_MESSAGE_IS_EXTENDED (0)
#define CAN_DIAGNOSTIC_MEASUREMENTS_IS_EXTENDED (0)
#define CAN_PT1000_STATE_IS_EXTENDED (0)
#define CAN_DIGITAL_INPUT_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define CAN_INQUIRY_PACKET_PACKET_ID_FIRMWARE_VERSION_CHOICE (10u)
#define CAN_INQUIRY_PACKET_PACKET_ID_GIT_HASH_CHOICE (11u)

#define CAN_CHARGE_CONTROL2_CC_CCS_READY_CCS_NOT_READY_CHOICE (0u)
#define CAN_CHARGE_CONTROL2_CC_CCS_READY_CCS_READY_CHOICE (1u)
#define CAN_CHARGE_CONTROL2_CC_CCS_READY_CCS_EMERGENCY_STOP_CHOICE (2u)

#define CAN_CHARGE_STATE2_CS_CE_STATE_A_CHOICE (0u)
#define CAN_CHARGE_STATE2_CS_CE_STATE_B_CHOICE (1u)
#define CAN_CHARGE_STATE2_CS_CE_STATE_C_CHOICE (2u)
#define CAN_CHARGE_STATE2_CS_CE_STATE_D_CHOICE (3u)
#define CAN_CHARGE_STATE2_CS_CE_STATE_E_CHOICE (4u)
#define CAN_CHARGE_STATE2_CS_CE_STATE_EC_CHOICE (5u)
#define CAN_CHARGE_STATE2_CS_CE_STATE_B0_CHOICE (6u)
#define CAN_CHARGE_STATE2_CS_CE_STATE_INVALID_CHOICE (7u)
#define CAN_CHARGE_STATE2_CS_CE_STATE_SNA_CHOICE (15u)

#define CAN_CHARGE_STATE2_CS_ID_STATE_NOT_CONNECTED_CHOICE (0u)
#define CAN_CHARGE_STATE2_CS_ID_STATE_CONNECTED_CHOICE (1u)
#define CAN_CHARGE_STATE2_CS_ID_STATE_INVALID_CHOICE (14u)
#define CAN_CHARGE_STATE2_CS_ID_STATE_SNA_CHOICE (15u)

#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_NO_STOP_CHOICE (0u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_EMERGENCY_INPUT_CHOICE (1u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_COM_TIMEOUT_CHOICE (2u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_TEMP1_MALFUNCTION_CHOICE (3u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_TEMP2_MALFUNCTION_CHOICE (4u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_TEMP3_MALFUNCTION_CHOICE (5u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_TEMP4_MALFUNCTION_CHOICE (6u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_TEMP1_OVERTEMP_CHOICE (7u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_TEMP2_OVERTEMP_CHOICE (8u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_TEMP3_OVERTEMP_CHOICE (9u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_TEMP4_OVERTEMP_CHOICE (10u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_ID_MALFUNCTION_CHOICE (11u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_CE_MALFUNCTION_CHOICE (12u)
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_HV_READY_MALFUNCTION_CHOICE (13u)

#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_UNKNOWN_CHOICE (0u)
#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_A_CHOICE (1u)
#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_B_CHOICE (2u)
#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_C_CHOICE (3u)
#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_D_CHOICE (4u)
#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_E_CHOICE (5u)
#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_F_CHOICE (6u)
#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_INVALID_CHOICE (7u)

#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_NO_CABLE_DETECTED_CHOICE (0u)
#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_13_A_CHOICE (1u)
#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_20_A_CHOICE (2u)
#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_32_A_CHOICE (3u)
#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_63_70_A_CHOICE (4u)
#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_TYPE1_CONNECTED_CHOICE (5u)
#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_TYPE1_CONNECTED_BUTTON_PRESSED_CHOICE (6u)
#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_ERROR_CHOICE (7u)

#define CAN_CHARGE_STATE1_CS_CONTACTOR2_STATE_OPEN_CHOICE (0u)
#define CAN_CHARGE_STATE1_CS_CONTACTOR2_STATE_CLOSE_CHOICE (1u)
#define CAN_CHARGE_STATE1_CS_CONTACTOR2_STATE_NOT_CONFIGURED_CHOICE (3u)

#define CAN_CHARGE_STATE1_CS_CONTACTOR1_STATE_OPEN_CHOICE (0u)
#define CAN_CHARGE_STATE1_CS_CONTACTOR1_STATE_CLOSE_CHOICE (1u)
#define CAN_CHARGE_STATE1_CS_CONTACTOR1_STATE_NOT_CONFIGURED_CHOICE (3u)

#define CAN_CHARGE_STATE1_CS_ESTOP3_CHARGING_ABORT_FALSE_CHOICE (0u)
#define CAN_CHARGE_STATE1_CS_ESTOP3_CHARGING_ABORT_TRUE_CHOICE (1u)
#define CAN_CHARGE_STATE1_CS_ESTOP3_CHARGING_ABORT_NOT_CONFIGURED_CHOICE (3u)

#define CAN_CHARGE_STATE1_CS_ESTOP2_CHARGING_ABORT_FALSE_CHOICE (0u)
#define CAN_CHARGE_STATE1_CS_ESTOP2_CHARGING_ABORT_TRUE_CHOICE (1u)
#define CAN_CHARGE_STATE1_CS_ESTOP2_CHARGING_ABORT_NOT_CONFIGURED_CHOICE (3u)

#define CAN_CHARGE_STATE1_CS_ESTOP1_CHARGING_ABORT_FALSE_CHOICE (0u)
#define CAN_CHARGE_STATE1_CS_ESTOP1_CHARGING_ABORT_TRUE_CHOICE (1u)
#define CAN_CHARGE_STATE1_CS_ESTOP1_CHARGING_ABORT_NOT_CONFIGURED_CHOICE (3u)

#define CAN_FIRMWARE_VERSION_PLATFORM_TYPE_CHARGE_SOM_CHOICE (129u)
#define CAN_FIRMWARE_VERSION_PLATFORM_TYPE_CCY_CHOICE (130u)

#define CAN_FIRMWARE_VERSION_APPLICATION_TYPE_FIRMWARE_CHOICE (3u)
#define CAN_FIRMWARE_VERSION_APPLICATION_TYPE_END__OF__LINE_CHOICE (4u)
#define CAN_FIRMWARE_VERSION_APPLICATION_TYPE_QUALIFICATION_CHOICE (5u)

#define CAN_PT1000_STATE_PT1_TEMPERATURE_TEMP_SENSOR_NOT_USED_CHOICE (8191)

#define CAN_PT1000_STATE_PT2_TEMPERATURE_TEMP_SENSOR_NOT_USED_CHOICE (8191)

#define CAN_PT1000_STATE_PT3_TEMPERATURE_TEMP_SENSOR_NOT_USED_CHOICE (8191)

#define CAN_PT1000_STATE_PT4_TEMPERATURE_TEMP_SENSOR_NOT_USED_CHOICE (8191)

/* Frame Names. */
#define CAN_INQUIRY_PACKET_NAME "InquiryPacket"
#define CAN_DIGITAL_OUTPUT_NAME "DigitalOutput"
#define CAN_DIAGNOSTIC_MEASUREMENTS2_NAME "DiagnosticMeasurements2"
#define CAN_ANALOG_INPUT04_NAME "AnalogInput04"
#define CAN_ANALOG_INPUT03_NAME "AnalogInput03"
#define CAN_ANALOG_INPUT02_NAME "AnalogInput02"
#define CAN_ANALOG_INPUT01_NAME "AnalogInput01"
#define CAN_CHARGE_CONTROL2_NAME "ChargeControl2"
#define CAN_CHARGE_STATE2_NAME "ChargeState2"
#define CAN_CHARGE_STATE1_NAME "ChargeState1"
#define CAN_CHARGE_CONTROL1_NAME "ChargeControl1"
#define CAN_FIRMWARE_VERSION_NAME "FirmwareVersion"
#define CAN_GIT_HASH_NAME "GitHash"
#define CAN_ERROR_MESSAGE_NAME "ErrorMessage"
#define CAN_DIAGNOSTIC_MEASUREMENTS_NAME "DiagnosticMeasurements"
#define CAN_PT1000_STATE_NAME "PT1000State"
#define CAN_DIGITAL_INPUT_NAME "DigitalInput"

/* Signal Names. */
#define CAN_INQUIRY_PACKET_PACKET_ID_NAME "PacketId"
#define CAN_DIGITAL_OUTPUT_DO_SAFETY_MOTOR_OUT1_NAME "DO_SAFETY_MOTOR_OUT1"
#define CAN_DIGITAL_OUTPUT_DO_SAFETY_MOTOR_OUT2_NAME "DO_SAFETY_MOTOR_OUT2"
#define CAN_DIGITAL_OUTPUT_DO_CP_INVERT_NAME "DO_CP_INVERT"
#define CAN_DIGITAL_OUTPUT_DO_PP_SAE_IEC_NAME "DO_PP_SAE_IEC"
#define CAN_DIGITAL_OUTPUT_DO_SAFETY_HVSW1_HS_NAME "DO_SAFETY_HVSW1_HS"
#define CAN_DIGITAL_OUTPUT_DO_SAFETY_HVSW2_HS_NAME "DO_SAFETY_HVSW2_HS"
#define CAN_DIGITAL_OUTPUT_DO_SAFETY_GPIO_EXP_NAME "DO_SAFETY_GPIO_EXP"
#define CAN_DIGITAL_OUTPUT_DO_SAFETY_IMD_OD_EN_NAME "DO_SAFETY_IMD_OD_EN"
#define CAN_DIGITAL_OUTPUT_DO_PT1000_CTRLEN4_NAME "DO_PT1000_CTRLEN4"
#define CAN_DIGITAL_OUTPUT_DO_SAFETY_HVSW3_PRECHARGE_NAME "DO_SAFETY_HVSW3_PRECHARGE"
#define CAN_DIGITAL_OUTPUT_DO_PT1000_CTRLEN1_NAME "DO_PT1000_CTRLEN1"
#define CAN_DIGITAL_OUTPUT_DO_PT1000_CTRLEN2_NAME "DO_PT1000_CTRLEN2"
#define CAN_DIGITAL_OUTPUT_DO_PT1000_CTRLEN3_NAME "DO_PT1000_CTRLEN3"
#define CAN_DIGITAL_OUTPUT_DO_SAFETY_CP_STATE_C_NAME "DO_SAFETY_CP_STATE_C"
#define CAN_DIGITAL_OUTPUT_DO_CP_DUTYCYCLE_NAME "DO_CP_Dutycycle"
#define CAN_DIAGNOSTIC_MEASUREMENTS2_DM_CE_ADC_VAL_NAME "DM_CE_ADC_VAL"
#define CAN_DIAGNOSTIC_MEASUREMENTS2_DM_ID_ADC_VAL_NAME "DM_ID_ADC_VAL"
#define CAN_ANALOG_INPUT04_AI_PT1000_CFB3_4_NAME "AI_PT1000_CFB3_4"
#define CAN_ANALOG_INPUT04_AI_INT_TEMP_NAME "AI_INT_TEMP"
#define CAN_ANALOG_INPUT04_AI_INT_REFVOLT_NAME "AI_INT_REFVOLT"
#define CAN_ANALOG_INPUT03_AI_SAFETY_PRECHARGE_CFB_NAME "AI_SAFETY_PRECHARGE_CFB"
#define CAN_ANALOG_INPUT03_AI_SAFETY_HS1_CFB_NAME "AI_SAFETY_HS1_CFB"
#define CAN_ANALOG_INPUT03_AI_SAFETY_HS2_CFB_NAME "AI_SAFETY_HS2_CFB"
#define CAN_ANALOG_INPUT03_AI_PT1000_CFB1_2_NAME "AI_PT1000_CFB1_2"
#define CAN_ANALOG_INPUT02_AI_CP_BUFFERED_NEG_ADC_NAME "AI_CP_BUFFERED_NEG_ADC"
#define CAN_ANALOG_INPUT02_AI_CP_BUFFERED_POS_ADC_NAME "AI_CP_BUFFERED_POS_ADC"
#define CAN_ANALOG_INPUT02_AI_PP_VALUE_ADC_NAME "AI_PP_VALUE_ADC"
#define CAN_ANALOG_INPUT02_AI_SAFETY_U_IN_ADC_NAME "AI_SAFETY_U_IN_ADC"
#define CAN_ANALOG_INPUT01_AI_PT1000_LEAD1_1_NAME "AI_PT1000_LEAD1_1"
#define CAN_ANALOG_INPUT01_AI_PT1000_LEAD1_2_NAME "AI_PT1000_LEAD1_2"
#define CAN_ANALOG_INPUT01_AI_PT1000_LEAD1_3_NAME "AI_PT1000_LEAD1_3"
#define CAN_ANALOG_INPUT01_AI_PT1000_LEAD1_4_NAME "AI_PT1000_LEAD1_4"
#define CAN_CHARGE_CONTROL2_CC_CCS_READY_NAME "CC_CCSReady"
#define CAN_CHARGE_CONTROL2_CC_CONTROLLER_RESET_NAME "CC_ControllerReset"
#define CAN_CHARGE_STATE2_CS_CE_STATE_NAME "CS_CE_State"
#define CAN_CHARGE_STATE2_CS_ID_STATE_NAME "CS_ID_State"
#define CAN_CHARGE_STATE2_CS_E_STOP_REASON_NAME "CS_EStop_Reason"
#define CAN_CHARGE_STATE1_CS_PWM_ACTIVE_NAME "CS_PWM_Active"
#define CAN_CHARGE_STATE1_CS_CURRENT_DUTY_CYCLE_NAME "CS_CurrentDutyCycle"
#define CAN_CHARGE_STATE1_CS_DIODE_FAULT_NAME "CS_DiodeFault"
#define CAN_CHARGE_STATE1_CS_CP_SHORT_CIRCUIT_NAME "CS_CpShortCircuit"
#define CAN_CHARGE_STATE1_CS_CURRENT_CP_STATE_NAME "CS_CurrentCpState"
#define CAN_CHARGE_STATE1_CS_CURRENT_PP_STATE_NAME "CS_CurrentPpState"
#define CAN_CHARGE_STATE1_CS_HV_READY_NAME "CS_HV_Ready"
#define CAN_CHARGE_STATE1_CS_CONTACTOR2_ERROR_NAME "CS_Contactor2Error"
#define CAN_CHARGE_STATE1_CS_CONTACTOR2_STATE_NAME "CS_Contactor2State"
#define CAN_CHARGE_STATE1_CS_CONTACTOR1_ERROR_NAME "CS_Contactor1Error"
#define CAN_CHARGE_STATE1_CS_CONTACTOR1_STATE_NAME "CS_Contactor1State"
#define CAN_CHARGE_STATE1_CS_ESTOP3_CHARGING_ABORT_NAME "CS_Estop3ChargingAbort"
#define CAN_CHARGE_STATE1_CS_ESTOP2_CHARGING_ABORT_NAME "CS_Estop2ChargingAbort"
#define CAN_CHARGE_STATE1_CS_ESTOP1_CHARGING_ABORT_NAME "CS_Estop1ChargingAbort"
#define CAN_CHARGE_CONTROL1_CC_PWM_ACTIVE_NAME "CC_PWM_Active"
#define CAN_CHARGE_CONTROL1_CC_TARGET_DUTY_CYCLE_NAME "CC_TargetDutyCycle"
#define CAN_CHARGE_CONTROL1_CC_CONTACTOR2_STATE_NAME "CC_Contactor2State"
#define CAN_CHARGE_CONTROL1_CC_CONTACTOR1_STATE_NAME "CC_Contactor1State"
#define CAN_FIRMWARE_VERSION_MAJOR_VERSION_NAME "MajorVersion"
#define CAN_FIRMWARE_VERSION_MINOR_VERSION_NAME "MinorVersion"
#define CAN_FIRMWARE_VERSION_BUILD_VERSION_NAME "BuildVersion"
#define CAN_FIRMWARE_VERSION_PLATFORM_TYPE_NAME "PlatformType"
#define CAN_FIRMWARE_VERSION_APPLICATION_TYPE_NAME "ApplicationType"
#define CAN_GIT_HASH_HASH_SIGNAL_NAME "HashSignal"
#define CAN_ERROR_MESSAGE_ERROR_ACTIVE_NAME "ErrorActive"
#define CAN_ERROR_MESSAGE_ERROR_MODULE_NAME "ErrorModule"
#define CAN_ERROR_MESSAGE_ERROR_REASON_NAME "ErrorReason"
#define CAN_ERROR_MESSAGE_ERROR_ADD_DATA1_NAME "ErrorAddData1"
#define CAN_ERROR_MESSAGE_ERROR_ADD_DATA2_NAME "ErrorAddData2"
#define CAN_DIAGNOSTIC_MEASUREMENTS_DM_CP_VOLTAGE_NEGATIVE_SIDE_NAME "DM_CP_VoltageNegativeSide"
#define CAN_DIAGNOSTIC_MEASUREMENTS_DM_CP_VOLTAGE_POSITIVE_SIDE_NAME "DM_CP_VoltagePositiveSide"
#define CAN_DIAGNOSTIC_MEASUREMENTS_DM_PP_VOLTAGE_NAME "DM_PP_Voltage"
#define CAN_PT1000_STATE_PT1_TEMPERATURE_NAME "PT1_Temperature"
#define CAN_PT1000_STATE_PT1_SELFTEST_FAILED_NAME "PT1_SelftestFailed"
#define CAN_PT1000_STATE_PT1_CHARGING_STOPPED_NAME "PT1_ChargingStopped"
#define CAN_PT1000_STATE_PT2_TEMPERATURE_NAME "PT2_Temperature"
#define CAN_PT1000_STATE_PT2_SELFTEST_FAILED_NAME "PT2_SelftestFailed"
#define CAN_PT1000_STATE_PT2_CHARGING_STOPPED_NAME "PT2_ChargingStopped"
#define CAN_PT1000_STATE_PT3_TEMPERATURE_NAME "PT3_Temperature"
#define CAN_PT1000_STATE_PT3_SELFTEST_FAILED_NAME "PT3_SelftestFailed"
#define CAN_PT1000_STATE_PT3_CHARGING_STOPPED_NAME "PT3_ChargingStopped"
#define CAN_PT1000_STATE_PT4_TEMPERATURE_NAME "PT4_Temperature"
#define CAN_PT1000_STATE_PT4_SELFTEST_FAILED_NAME "PT4_SelftestFailed"
#define CAN_PT1000_STATE_PT4_CHARGING_STOPPED_NAME "PT4_ChargingStopped"
#define CAN_DIGITAL_INPUT_DI_SAFETY_K1_IN_NAME "DI_SAFETY_K1_IN"
#define CAN_DIGITAL_INPUT_DI_SAFETY_MOTOR_OUT1_NAME "DI_SAFETY_MOTOR_OUT1"
#define CAN_DIGITAL_INPUT_DI_SAFETY_MOTOR_OUT2_NAME "DI_SAFETY_MOTOR_OUT2"
#define CAN_DIGITAL_INPUT_DI_SAFETY_MOTOR_FAULT_NAME "DI_SAFETY_MOTOR_FAULT"
#define CAN_DIGITAL_INPUT_DI_CP_INVERT_NAME "DI_CP_INVERT"
#define CAN_DIGITAL_INPUT_DI_EV_CP_EDGE_NAME "DI_EV_CP_EDGE"
#define CAN_DIGITAL_INPUT_DI_SAFETY_DEV_2_NAME "DI_SAFETY_DEV_2"
#define CAN_DIGITAL_INPUT_DI_SAFETY_DEV_1_NAME "DI_SAFETY_DEV_1"
#define CAN_DIGITAL_INPUT_DI_PP_SAE_IEC_NAME "DI_PP_SAE_IEC"
#define CAN_DIGITAL_INPUT_DI_SAFETY_HVSW1_HS_NAME "DI_SAFETY_HVSW1_HS"
#define CAN_DIGITAL_INPUT_DI_SAFETY_HVSW2_HS_NAME "DI_SAFETY_HVSW2_HS"
#define CAN_DIGITAL_INPUT_DI_SAFETY_GPIO_EXP_NAME "DI_SAFETY_GPIO_EXP"
#define CAN_DIGITAL_INPUT_DI_SAFETY_IMD_OD_EN_NAME "DI_SAFETY_IMD_OD_EN"
#define CAN_DIGITAL_INPUT_DI_PT4_EN_NAME "DI_PT4_EN"
#define CAN_DIGITAL_INPUT_DI_SAFETY_HVSW3_PRECHARGE_NAME "DI_SAFETY_HVSW3_PRECHARGE"
#define CAN_DIGITAL_INPUT_DI_SAFETY_K2_IN_NAME "DI_SAFETY_K2_IN"
#define CAN_DIGITAL_INPUT_DI_PT1_EN_NAME "DI_PT1_EN"
#define CAN_DIGITAL_INPUT_DI_PT2_EN_NAME "DI_PT2_EN"
#define CAN_DIGITAL_INPUT_DI_PT3_EN_NAME "DI_PT3_EN"
#define CAN_DIGITAL_INPUT_DI_SAFETY_CP_STATE_C_NAME "DI_SAFETY_CP_STATE_C"
#define CAN_DIGITAL_INPUT_DI_ESTOP1_NAME "DI_ESTOP1"
#define CAN_DIGITAL_INPUT_DI_ESTOP2_NAME "DI_ESTOP2"
#define CAN_DIGITAL_INPUT_DI_ESTOP3_NAME "DI_ESTOP3"

/**
 * Signals in message InquiryPacket.
 *
 * This packet is used to request a special message from the safety controller
 *
 * All signal values are as on the CAN bus.
 */
struct can_inquiry_packet_t {
    /**
     * The ID, which message shall be requested. Supported values are described below.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t packet_id;
};

/**
 * Signals in message DigitalOutput.
 *
 * All signal values are as on the CAN bus.
 */
struct can_digital_output_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_safety_motor_out1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_safety_motor_out2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_cp_invert;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_pp_sae_iec;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_safety_hvsw1_hs;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_safety_hvsw2_hs;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_safety_gpio_exp;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_safety_imd_od_en;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_pt1000_ctrlen4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_safety_hvsw3_precharge;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_pt1000_ctrlen1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_pt1000_ctrlen2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_pt1000_ctrlen3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_safety_cp_state_c;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t do_cp_dutycycle;
};

/**
 * Signals in message DiagnosticMeasurements2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_diagnostic_measurements2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dm_ce_adc_val;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dm_id_adc_val;
};

/**
 * Signals in message AnalogInput04.
 *
 * All signal values are as on the CAN bus.
 */
struct can_analog_input04_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_pt1000_cfb3_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_int_temp;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_int_refvolt;
};

/**
 * Signals in message AnalogInput03.
 *
 * All signal values are as on the CAN bus.
 */
struct can_analog_input03_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_safety_precharge_cfb;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_safety_hs1_cfb;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_safety_hs2_cfb;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_pt1000_cfb1_2;
};

/**
 * Signals in message AnalogInput02.
 *
 * All signal values are as on the CAN bus.
 */
struct can_analog_input02_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_cp_buffered_neg_adc;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_cp_buffered_pos_adc;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_pp_value_adc;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_safety_u_in_adc;
};

/**
 * Signals in message AnalogInput01.
 *
 * All signal values are as on the CAN bus.
 */
struct can_analog_input01_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_pt1000_lead1_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_pt1000_lead1_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_pt1000_lead1_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ai_pt1000_lead1_4;
};

/**
 * Signals in message ChargeControl2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_charge_control2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cc_ccs_ready;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cc_controller_reset;
};

/**
 * Signals in message ChargeState2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_charge_state2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ce_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_id_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_e_stop_reason;
};

/**
 * Signals in message ChargeState1.
 *
 * This message shall be sent from safety controller to host processor for indicating the state of the charging session as well as the state of connected peripherals.
 *
 * All signal values are as on the CAN bus.
 */
struct can_charge_state1_t {
    /**
     * Feedback if PWM is active. 0 means not active, 1 means active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_pwm_active;

    /**
     * The current duty cycle between 0.0% and 100.0%. If the PWM is not aczive this signal is 0
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t cs_current_duty_cycle;

    /**
     *  Is set when the safety controller detects that the diode on EV side is missing.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_diode_fault;

    /**
     *  Is set when the safety controller detects a short-circuit condition between CP and PE line.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_cp_short_circuit;

    /**
     * Current state of the control pilot. See value mappings below
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_current_cp_state;

    /**
     * State of the proximity pin. For fixed cables at CCS2, this value is 0x0: No Cable detected
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_current_pp_state;

    /**
     * This is the state of the HV ready or State C output. This output is high, if the chargeSOM dont see any errors and CP is at state C. Otherwise it is low.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_hv_ready;

    /**
     * Is set when an error in the contactor is detected
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_contactor2_error;

    /**
     * Is set when the contactor is closed
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_contactor2_state;

    /**
     * Is set when an error in the contactor is detected
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_contactor1_error;

    /**
     * Is set when the contactor is closed
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_contactor1_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_estop3_charging_abort;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_estop2_charging_abort;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_estop1_charging_abort;
};

/**
 * Signals in message ChargeControl1.
 *
 * This message shall be sent from the host processor to the safety controller to control the peripherals connected to the safety controller.
 *
 * All signal values are as on the CAN bus.
 */
struct can_charge_control1_t {
    /**
     * This flag indicates if the PWM should be activated. At a value of 0, the CP level is also 0V. At a value of 1, the CP level is dependant of the duty cycle
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cc_pwm_active;

    /**
     * Duty cycle between 0.0 and 100.0%. Values above 100.0% are set as 100%. Only valid if the signal CC_PWM_Active is 1
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t cc_target_duty_cycle;

    /**
     * Request to close the contactor state. A value of 0 means open contactor, a value of 1 means closed contactor. The contactors are only closed if the system has no errors and is in state C.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cc_contactor2_state;

    /**
     * Request to close the contactor state. A value of 0 means open contactor, a value of 1 means closed contactor. The contactors are only closed if the system has no errors and is in state C.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cc_contactor1_state;
};

/**
 * Signals in message FirmwareVersion.
 *
 * This message provides information about the type and version of the flashed firmware
 *
 * All signal values are as on the CAN bus.
 */
struct can_firmware_version_t {
    /**
     * Major version of the firmware
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t major_version;

    /**
     * Minor version of the firmware
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t minor_version;

    /**
     * Build or patch version of the firmware
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t build_version;

    /**
     * This firmware can be used for several products with minor changes in the build process. The platform type describes the used platform
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t platform_type;

    /**
     * The type of firmware. See possible values below
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t application_type;
};

/**
 * Signals in message GitHash.
 *
 * This message provides information about the GIT hash, written in the firmware
 *
 * All signal values are as on the CAN bus.
 */
struct can_git_hash_t {
    /**
     * First 8 byte of the 160 bit (SHA-1) GIT hash
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t hash_signal;
};

/**
 * Signals in message ErrorMessage.
 *
 * All signal values are as on the CAN bus.
 */
struct can_error_message_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_active;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t error_module;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t error_reason;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t error_add_data1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t error_add_data2;
};

/**
 * Signals in message DiagnosticMeasurements.
 *
 * All signal values are as on the CAN bus.
 */
struct can_diagnostic_measurements_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t dm_cp_voltage_negative_side;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t dm_cp_voltage_positive_side;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t dm_pp_voltage;
};

/**
 * Signals in message PT1000State.
 *
 * This message shall be sent from safety controller to host processor for indicating the state of the connected temperature sensors
 *
 * All signal values are as on the CAN bus.
 */
struct can_pt1000_state_t {
    /**
     * Current temperature of PT1000 channel in  C with one decimal digit. 0x1FFF stands for: temp sensor not used.
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pt1_temperature;

    /**
     * Indicates whether this PT1000 channel is disturbed, multiple channel can signal the condition in parallel.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pt1_selftest_failed;

    /**
     * Indicates whether this PT1000 channel prevents charging, multiple channel can signal the condition in parallel.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pt1_charging_stopped;

    /**
     * Current temperature of PT1000 channel in  C with one decimal digit. 0x1FFF stands for: temp sensor not used.
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pt2_temperature;

    /**
     * Indicates whether this PT1000 channel is disturbed, multiple channel can signal the condition in parallel.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pt2_selftest_failed;

    /**
     * Indicates whether this PT1000 channel prevents charging, multiple channel can signal the condition in parallel.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pt2_charging_stopped;

    /**
     * Current temperature of PT1000 channel in  C with one decimal digit. 0x1FFF stands for: temp sensor not used.
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pt3_temperature;

    /**
     * Indicates whether this PT1000 channel is disturbed, multiple channel can signal the condition in parallel.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pt3_selftest_failed;

    /**
     * Indicates whether this PT1000 channel prevents charging, multiple channel can signal the condition in parallel.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pt3_charging_stopped;

    /**
     * Current temperature of PT1000 channel in  C with one decimal digit. 0x1FFF stands for: temp sensor not used.
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pt4_temperature;

    /**
     * Indicates whether this PT1000 channel is disturbed, multiple channel can signal the condition in parallel.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pt4_selftest_failed;

    /**
     * Indicates whether this PT1000 channel prevents charging, multiple channel can signal the condition in parallel.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pt4_charging_stopped;
};

/**
 * Signals in message DigitalInput.
 *
 * All signal values are as on the CAN bus.
 */
struct can_digital_input_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_k1_in;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_motor_out1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_motor_out2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_motor_fault;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_cp_invert;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_ev_cp_edge;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_dev_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_dev_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_pp_sae_iec;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_hvsw1_hs;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_hvsw2_hs;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_gpio_exp;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_imd_od_en;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_pt4_en;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_hvsw3_precharge;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_k2_in;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_pt1_en;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_pt2_en;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_pt3_en;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_safety_cp_state_c;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_estop1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_estop2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t di_estop3;
};

/**
 * Pack message InquiryPacket.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_inquiry_packet_pack(
    uint8_t *dst_p,
    const struct can_inquiry_packet_t *src_p,
    size_t size);

/**
 * Unpack message InquiryPacket.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_inquiry_packet_unpack(
    struct can_inquiry_packet_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from InquiryPacket.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_inquiry_packet_init(struct can_inquiry_packet_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_inquiry_packet_packet_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_inquiry_packet_packet_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_inquiry_packet_packet_id_is_in_range(uint8_t value);

/**
 * Pack message DigitalOutput.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_digital_output_pack(
    uint8_t *dst_p,
    const struct can_digital_output_t *src_p,
    size_t size);

/**
 * Unpack message DigitalOutput.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_digital_output_unpack(
    struct can_digital_output_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DigitalOutput.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_digital_output_init(struct can_digital_output_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_safety_motor_out1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_safety_motor_out1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_safety_motor_out1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_safety_motor_out2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_safety_motor_out2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_safety_motor_out2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_cp_invert_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_cp_invert_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_cp_invert_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_pp_sae_iec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_pp_sae_iec_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_pp_sae_iec_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_safety_hvsw1_hs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_safety_hvsw1_hs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_safety_hvsw1_hs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_safety_hvsw2_hs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_safety_hvsw2_hs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_safety_hvsw2_hs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_safety_gpio_exp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_safety_gpio_exp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_safety_gpio_exp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_safety_imd_od_en_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_safety_imd_od_en_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_safety_imd_od_en_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_pt1000_ctrlen4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_pt1000_ctrlen4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_pt1000_ctrlen4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_safety_hvsw3_precharge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_safety_hvsw3_precharge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_safety_hvsw3_precharge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_pt1000_ctrlen1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_pt1000_ctrlen1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_pt1000_ctrlen1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_pt1000_ctrlen2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_pt1000_ctrlen2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_pt1000_ctrlen2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_pt1000_ctrlen3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_pt1000_ctrlen3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_pt1000_ctrlen3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_safety_cp_state_c_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_safety_cp_state_c_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_safety_cp_state_c_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_output_do_cp_dutycycle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_output_do_cp_dutycycle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_output_do_cp_dutycycle_is_in_range(uint8_t value);

/**
 * Pack message DiagnosticMeasurements2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_diagnostic_measurements2_pack(
    uint8_t *dst_p,
    const struct can_diagnostic_measurements2_t *src_p,
    size_t size);

/**
 * Unpack message DiagnosticMeasurements2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_diagnostic_measurements2_unpack(
    struct can_diagnostic_measurements2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DiagnosticMeasurements2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_diagnostic_measurements2_init(struct can_diagnostic_measurements2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_diagnostic_measurements2_dm_ce_adc_val_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_diagnostic_measurements2_dm_ce_adc_val_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_diagnostic_measurements2_dm_ce_adc_val_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_diagnostic_measurements2_dm_id_adc_val_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_diagnostic_measurements2_dm_id_adc_val_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_diagnostic_measurements2_dm_id_adc_val_is_in_range(uint16_t value);

/**
 * Pack message AnalogInput04.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_analog_input04_pack(
    uint8_t *dst_p,
    const struct can_analog_input04_t *src_p,
    size_t size);

/**
 * Unpack message AnalogInput04.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_analog_input04_unpack(
    struct can_analog_input04_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AnalogInput04.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_analog_input04_init(struct can_analog_input04_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input04_ai_pt1000_cfb3_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input04_ai_pt1000_cfb3_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input04_ai_pt1000_cfb3_4_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input04_ai_int_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input04_ai_int_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input04_ai_int_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input04_ai_int_refvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input04_ai_int_refvolt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input04_ai_int_refvolt_is_in_range(uint16_t value);

/**
 * Pack message AnalogInput03.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_analog_input03_pack(
    uint8_t *dst_p,
    const struct can_analog_input03_t *src_p,
    size_t size);

/**
 * Unpack message AnalogInput03.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_analog_input03_unpack(
    struct can_analog_input03_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AnalogInput03.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_analog_input03_init(struct can_analog_input03_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input03_ai_safety_precharge_cfb_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input03_ai_safety_precharge_cfb_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input03_ai_safety_precharge_cfb_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input03_ai_safety_hs1_cfb_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input03_ai_safety_hs1_cfb_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input03_ai_safety_hs1_cfb_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input03_ai_safety_hs2_cfb_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input03_ai_safety_hs2_cfb_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input03_ai_safety_hs2_cfb_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input03_ai_pt1000_cfb1_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input03_ai_pt1000_cfb1_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input03_ai_pt1000_cfb1_2_is_in_range(uint16_t value);

/**
 * Pack message AnalogInput02.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_analog_input02_pack(
    uint8_t *dst_p,
    const struct can_analog_input02_t *src_p,
    size_t size);

/**
 * Unpack message AnalogInput02.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_analog_input02_unpack(
    struct can_analog_input02_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AnalogInput02.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_analog_input02_init(struct can_analog_input02_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input02_ai_cp_buffered_neg_adc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input02_ai_cp_buffered_neg_adc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input02_ai_cp_buffered_neg_adc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input02_ai_cp_buffered_pos_adc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input02_ai_cp_buffered_pos_adc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input02_ai_cp_buffered_pos_adc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input02_ai_pp_value_adc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input02_ai_pp_value_adc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input02_ai_pp_value_adc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input02_ai_safety_u_in_adc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input02_ai_safety_u_in_adc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input02_ai_safety_u_in_adc_is_in_range(uint16_t value);

/**
 * Pack message AnalogInput01.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_analog_input01_pack(
    uint8_t *dst_p,
    const struct can_analog_input01_t *src_p,
    size_t size);

/**
 * Unpack message AnalogInput01.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_analog_input01_unpack(
    struct can_analog_input01_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from AnalogInput01.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_analog_input01_init(struct can_analog_input01_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input01_ai_pt1000_lead1_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input01_ai_pt1000_lead1_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input01_ai_pt1000_lead1_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input01_ai_pt1000_lead1_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input01_ai_pt1000_lead1_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input01_ai_pt1000_lead1_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input01_ai_pt1000_lead1_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input01_ai_pt1000_lead1_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input01_ai_pt1000_lead1_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_analog_input01_ai_pt1000_lead1_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_analog_input01_ai_pt1000_lead1_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_analog_input01_ai_pt1000_lead1_4_is_in_range(uint16_t value);

/**
 * Pack message ChargeControl2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_charge_control2_pack(
    uint8_t *dst_p,
    const struct can_charge_control2_t *src_p,
    size_t size);

/**
 * Unpack message ChargeControl2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_charge_control2_unpack(
    struct can_charge_control2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ChargeControl2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_charge_control2_init(struct can_charge_control2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_control2_cc_ccs_ready_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_control2_cc_ccs_ready_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_control2_cc_ccs_ready_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_control2_cc_controller_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_control2_cc_controller_reset_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_control2_cc_controller_reset_is_in_range(uint8_t value);

/**
 * Pack message ChargeState2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_charge_state2_pack(
    uint8_t *dst_p,
    const struct can_charge_state2_t *src_p,
    size_t size);

/**
 * Unpack message ChargeState2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_charge_state2_unpack(
    struct can_charge_state2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ChargeState2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_charge_state2_init(struct can_charge_state2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state2_cs_ce_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state2_cs_ce_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state2_cs_ce_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state2_cs_id_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state2_cs_id_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state2_cs_id_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state2_cs_e_stop_reason_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state2_cs_e_stop_reason_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state2_cs_e_stop_reason_is_in_range(uint8_t value);

/**
 * Pack message ChargeState1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_charge_state1_pack(
    uint8_t *dst_p,
    const struct can_charge_state1_t *src_p,
    size_t size);

/**
 * Unpack message ChargeState1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_charge_state1_unpack(
    struct can_charge_state1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ChargeState1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_charge_state1_init(struct can_charge_state1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_pwm_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_pwm_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_pwm_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_charge_state1_cs_current_duty_cycle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_current_duty_cycle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_current_duty_cycle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_diode_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_diode_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_diode_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_cp_short_circuit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_cp_short_circuit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_cp_short_circuit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_current_cp_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_current_cp_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_current_cp_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_current_pp_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_current_pp_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_current_pp_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_hv_ready_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_hv_ready_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_hv_ready_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_contactor2_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_contactor2_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_contactor2_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_contactor2_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_contactor2_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_contactor2_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_contactor1_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_contactor1_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_contactor1_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_contactor1_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_contactor1_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_contactor1_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_estop3_charging_abort_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_estop3_charging_abort_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_estop3_charging_abort_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_estop2_charging_abort_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_estop2_charging_abort_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_estop2_charging_abort_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_state1_cs_estop1_charging_abort_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_state1_cs_estop1_charging_abort_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_state1_cs_estop1_charging_abort_is_in_range(uint8_t value);

/**
 * Pack message ChargeControl1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_charge_control1_pack(
    uint8_t *dst_p,
    const struct can_charge_control1_t *src_p,
    size_t size);

/**
 * Unpack message ChargeControl1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_charge_control1_unpack(
    struct can_charge_control1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ChargeControl1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_charge_control1_init(struct can_charge_control1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_control1_cc_pwm_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_control1_cc_pwm_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_control1_cc_pwm_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_charge_control1_cc_target_duty_cycle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_control1_cc_target_duty_cycle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_control1_cc_target_duty_cycle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_control1_cc_contactor2_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_control1_cc_contactor2_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_control1_cc_contactor2_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_charge_control1_cc_contactor1_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_charge_control1_cc_contactor1_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_charge_control1_cc_contactor1_state_is_in_range(uint8_t value);

/**
 * Pack message FirmwareVersion.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_firmware_version_pack(
    uint8_t *dst_p,
    const struct can_firmware_version_t *src_p,
    size_t size);

/**
 * Unpack message FirmwareVersion.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_firmware_version_unpack(
    struct can_firmware_version_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FirmwareVersion.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_firmware_version_init(struct can_firmware_version_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_firmware_version_major_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_firmware_version_major_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_firmware_version_major_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_firmware_version_minor_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_firmware_version_minor_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_firmware_version_minor_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_firmware_version_build_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_firmware_version_build_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_firmware_version_build_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_firmware_version_platform_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_firmware_version_platform_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_firmware_version_platform_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_firmware_version_application_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_firmware_version_application_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_firmware_version_application_type_is_in_range(uint8_t value);

/**
 * Pack message GitHash.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_git_hash_pack(
    uint8_t *dst_p,
    const struct can_git_hash_t *src_p,
    size_t size);

/**
 * Unpack message GitHash.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_git_hash_unpack(
    struct can_git_hash_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GitHash.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_git_hash_init(struct can_git_hash_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t can_git_hash_hash_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_git_hash_hash_signal_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_git_hash_hash_signal_is_in_range(uint64_t value);

/**
 * Pack message ErrorMessage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_error_message_pack(
    uint8_t *dst_p,
    const struct can_error_message_t *src_p,
    size_t size);

/**
 * Unpack message ErrorMessage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_error_message_unpack(
    struct can_error_message_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ErrorMessage.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_error_message_init(struct can_error_message_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_error_message_error_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_error_message_error_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_error_message_error_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_error_message_error_module_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_error_message_error_module_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_error_message_error_module_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_error_message_error_reason_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_error_message_error_reason_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_error_message_error_reason_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_error_message_error_add_data1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_error_message_error_add_data1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_error_message_error_add_data1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_error_message_error_add_data2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_error_message_error_add_data2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_error_message_error_add_data2_is_in_range(uint16_t value);

/**
 * Pack message DiagnosticMeasurements.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_diagnostic_measurements_pack(
    uint8_t *dst_p,
    const struct can_diagnostic_measurements_t *src_p,
    size_t size);

/**
 * Unpack message DiagnosticMeasurements.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_diagnostic_measurements_unpack(
    struct can_diagnostic_measurements_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DiagnosticMeasurements.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_diagnostic_measurements_init(struct can_diagnostic_measurements_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_diagnostic_measurements_dm_cp_voltage_negative_side_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_diagnostic_measurements_dm_cp_voltage_negative_side_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_diagnostic_measurements_dm_cp_voltage_negative_side_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_diagnostic_measurements_dm_cp_voltage_positive_side_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_diagnostic_measurements_dm_cp_voltage_positive_side_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_diagnostic_measurements_dm_cp_voltage_positive_side_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_diagnostic_measurements_dm_pp_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_diagnostic_measurements_dm_pp_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_diagnostic_measurements_dm_pp_voltage_is_in_range(int16_t value);

/**
 * Pack message PT1000State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_pt1000_state_pack(
    uint8_t *dst_p,
    const struct can_pt1000_state_t *src_p,
    size_t size);

/**
 * Unpack message PT1000State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_pt1000_state_unpack(
    struct can_pt1000_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PT1000State.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_pt1000_state_init(struct can_pt1000_state_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_pt1000_state_pt1_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt1_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt1_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_pt1000_state_pt1_selftest_failed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt1_selftest_failed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt1_selftest_failed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_pt1000_state_pt1_charging_stopped_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt1_charging_stopped_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt1_charging_stopped_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_pt1000_state_pt2_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt2_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt2_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_pt1000_state_pt2_selftest_failed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt2_selftest_failed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt2_selftest_failed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_pt1000_state_pt2_charging_stopped_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt2_charging_stopped_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt2_charging_stopped_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_pt1000_state_pt3_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt3_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt3_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_pt1000_state_pt3_selftest_failed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt3_selftest_failed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt3_selftest_failed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_pt1000_state_pt3_charging_stopped_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt3_charging_stopped_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt3_charging_stopped_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_pt1000_state_pt4_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt4_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt4_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_pt1000_state_pt4_selftest_failed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt4_selftest_failed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt4_selftest_failed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_pt1000_state_pt4_charging_stopped_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_pt1000_state_pt4_charging_stopped_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_pt1000_state_pt4_charging_stopped_is_in_range(uint8_t value);

/**
 * Pack message DigitalInput.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_digital_input_pack(
    uint8_t *dst_p,
    const struct can_digital_input_t *src_p,
    size_t size);

/**
 * Unpack message DigitalInput.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_digital_input_unpack(
    struct can_digital_input_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DigitalInput.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_digital_input_init(struct can_digital_input_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_k1_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_k1_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_k1_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_motor_out1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_motor_out1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_motor_out1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_motor_out2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_motor_out2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_motor_out2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_motor_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_motor_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_motor_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_cp_invert_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_cp_invert_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_cp_invert_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_ev_cp_edge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_ev_cp_edge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_ev_cp_edge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_dev_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_dev_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_dev_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_dev_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_dev_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_dev_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_pp_sae_iec_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_pp_sae_iec_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_pp_sae_iec_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_hvsw1_hs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_hvsw1_hs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_hvsw1_hs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_hvsw2_hs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_hvsw2_hs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_hvsw2_hs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_gpio_exp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_gpio_exp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_gpio_exp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_imd_od_en_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_imd_od_en_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_imd_od_en_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_pt4_en_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_pt4_en_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_pt4_en_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_hvsw3_precharge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_hvsw3_precharge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_hvsw3_precharge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_k2_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_k2_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_k2_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_pt1_en_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_pt1_en_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_pt1_en_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_pt2_en_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_pt2_en_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_pt2_en_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_pt3_en_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_pt3_en_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_pt3_en_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_safety_cp_state_c_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_safety_cp_state_c_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_safety_cp_state_c_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_estop1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_estop1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_estop1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_estop2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_estop2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_estop2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_digital_input_di_estop3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_digital_input_di_estop3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_digital_input_di_estop3_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
